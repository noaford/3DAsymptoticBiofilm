#ifndef _VECTOR_HPP_10142003_
#define _VECTOR_HPP_10142003_

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// \file
/// \brief Dense vector class
/// \ingroup linalg
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <algorithm> 
#include <iterator>
#include <limits>
#include <numeric>
#include <iosfwd>
#include <cstring>

#include "Assert.hpp"
#include "Math.hpp"
#include "SafeDelete.hpp"
#include "LinearAlgebra.hpp"

namespace LinearAlgebra
{
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Dense vector class
  /// \ingroup linalg
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  class Vector
  {
  public:
    friend class Matrix;
    friend class SparseMatrix;
    
  //@{
    /// \name Constructors & Destructors
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Default constructor
    /// 
    /// Constructs a vector of length 1 with zero values.
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    Vector( void ) : mSize(1), mData(NULL) 
    { 
      AllocateMemory();
      ZeroValues();
    }
	
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Size constructor
    /// 
    /// Constructs a vector of given length with zero values.
    /// \param Size [in] Length of the vector.
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    explicit Vector( size_t Size ) : mSize(Size), mData(NULL) 
    { 
      AllocateMemory();
      ZeroValues();
    }
    
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Value constructor
    /// 
    /// Constructs a vector of given length with each element assigned a given value
    /// \param Size [in] Length of the vector
    /// \param Value [in] Value to assign to each element
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    Vector( size_t Size, double Value ) : mSize(Size), mData(NULL) 
    { 
      AllocateMemory(); 
      SetValues(Value); 
    }
    
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Vector copy constructor
    /// \param v [in] Source vector    
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    Vector( const Vector& v ) : mSize(v.mSize), mData(NULL) 
    { 
      AllocateMemory(); 
      StraightCopy(v); 
    }
    
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Destructor
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ~Vector( void ) 
    { ReleaseMemory(); }
  //@}
  
  //@{
    /// \name Assignment operators.
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief %Vector assignment operator.
    ///
    /// If the source vector size matches the destination vector size, then the value are copied directly, else the destination 
    /// vector's memory is reallocated and the values are copied.
    /// \param v [in] Source vector.
    /// \return Reference to the destination vector after assignment.
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    Vector& operator= ( const Vector& v ) 
    { 
      if (mSize == v.mSize) 
        StraightCopy(v); 
      else 
      {
        mSize = v.mSize;
        AllocateCopy(v);
      }
      return(*this); 
    }
    
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief %Vector inplace addition operator.
    /// \warning The sizes of the source and destination vectors must match.
    /// \param v [in] Source vector.
    /// \return Reference to the destination vector after the addition.
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    Vector& operator+= ( const Vector& v ) 
    { 
      Assert( v.mSize == mSize, "Vector Sizes do not Match", __FILE__, __FUNCTION__, __LINE__ );
      std::transform( mData, mData+mSize, v.mData, mData, std::plus<double>() ); 
      return(*this); 
    }
    
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief %Vector inplace subtraction operator.
    /// \warning The sizes of the source and destination vectors must match.
    /// \param v [in] Source vector.
    /// \return Reference to the destination vector after the subtraction.
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    Vector&	operator-= ( const Vector& v ) 
    { 
      Assert( v.mSize == mSize, "Vector Sizes do not Match", __FILE__, __FUNCTION__, __LINE__ );
      std::transform( mData, mData+mSize, v.mData, mData, std::minus<double>() ); 
      return(*this); 
    }
    
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Scalar inplace multiplication operator.
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    Vector& operator*= ( const double c ) 
    { 
      std::transform( mData, mData+mSize, mData, std::bind2nd( std::multiplies<double>(), c ) );                   
      return(*this); 
    }
    
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Sparse Matrix inplace multiplication operator
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    Vector& operator*= ( const LinearAlgebra::SparseMatrix& A );
    
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Scalar inplace division operator.
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    Vector&	operator/= ( const double c ) 
    { 
      std::transform( mData, mData+mSize, mData, std::bind2nd( std::divides<double>(), c ) ); 
      return(*this); 
    }
  //@}
	
  //@{
    /// \name Block assignment functions.
    
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Sets all the elements of the vector to a given value.
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    void SetValues( const double Value ) 
    { std::fill( mData, mData+mSize, Value ); }
	
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Sets all the elements of the vector to zero.
    ///
    /// Same as calling Vector::SetValues( 0.0 ).
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	void ZeroValues( void ) 
    { SetValues(0.0); }
  //@}
	
  //@{
    /// \name Accessors
    
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief %Vector size accessor
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    size_t GetSize( void ) const 
    { return( mSize ); }
    
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief %Vector element reference operator.
    /// \warning Index must be less than the size of the vector.
    /// \param i [in] Element index.
    /// \return Reference to the i-th element of the vector.
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    double& operator() ( const size_t i ) 
    { 
      Assert( i < mSize, "Invalid Index", __FILE__, __FUNCTION__, __LINE__ );
      return( mData[i] ); 
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief %Vector element value operator.
    /// \warning Index must be less than the size of the vector.
    /// \param i [in] Element index.
    /// \return Value to the i-th element of the vector.
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
    double  operator() ( const size_t i ) const 
    { 
      Assert( i < mSize, "Invalid Index", __FILE__, __FUNCTION__, __LINE__ );
      return( mData[i] ); 
    }
  //@}
  
  //@{ 
    /// \name Functions for resizing the vector.
    
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Extends the size of the vector while preserving the current data within it.
    /// \warning All the new values of the vector are undefined
    /// \warning Function will not shrink the vector.  Does nothing if the given size is less than the current size.
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    void Extend( const int nSize )
    {
      if ( nSize > mSize )
      {
        double* temp = new double[nSize];
        Assert( temp != NULL, "Unable to Allocate Memory", __FILE__, __FUNCTION__, __LINE__ );
        
        memcpy( temp, mData, sizeof(double)*mSize );
        std::swap( temp, mData );
        memset( mData+mSize, 0, sizeof(double)*(nSize-mSize) );
        mSize = nSize;
        SafeDeleteArray( temp );
      }
    }
    
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Resizes the vector without preserving the current data within it.
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    void Resize( const int nSize )
    {
      ReleaseMemory();
      mSize = nSize;
      AllocateMemory();
    }
  //@}
    
  //@{
    /// \name Array functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Fill an array with the values from the vector for use with other numerical libraries.
    /// \warning The memory is owned by the caller and the function does not release any preallocated memory.
    /// \param x [in, out] Pointer to the array to fill with the vector values.
    /// \return Reference to the array passed as an argument after the vector values are copied. 
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    double* GetFullStorageArray( double*& x ) const
    {
      x = new double[mSize];
      Assert( x != NULL, "Unable to Allocate Memory", __FILE__, __FUNCTION__, __LINE__ );
      memcpy( x, mData, sizeof(double)*mSize );
      return( x );
    }
    
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Sets the element values of the vector to the values in an array.
    /// \warning The memory pointed to by the array is owned by the caller.
    /// \param x [in] Source array.
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    void SetFullStorageArray( double* x )
    {
      Assert( x != NULL, "Passes a NULL Array", __FILE__, __FUNCTION__, __LINE__ );
      memcpy( mData, x, sizeof(double)*mSize );
    }
  //@}

  //@{
    /// \name Stream operators
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Output stream insert operator.
    ///
    /// The element values of the vector are inserted on a single line with tab delimiters.
    /// \param o [in, out] Output stream.
    /// \param v [in] Source vector.
    /// \return Reference to the output stream after the vector is inserted.
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    friend std::ostream& operator<< ( std::ostream& o, const Vector& v ) 
    { 
      std::copy( v.mData, v.mData+v.mSize, std::ostream_iterator<double>(o, "\t") ); 
      o << "\n";
      return(o); 
    }
    
  //@{
    /// \name Elementry operators
    
    friend Vector operator* ( const Matrix& A, const Vector& x );
    friend Vector operator* ( const SparseMatrix& A, const Vector& x );
    
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Vector-Scalar multiplication operator.
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    friend Vector operator* ( const Vector& x, const double c )
    {
      LinearAlgebra::Vector result(x);
      return( result *= c );
    }
    
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Scalar-Vector multiplication operator.
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    friend Vector operator* ( const double c, const Vector& x )
    { return( x*c ); }
    
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Vector-Scalar division operators.
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    friend Vector operator/ ( const Vector& x, const double c )
    {
      LinearAlgebra::Vector result(x);
      return( result /= c );
    }
    
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief %Vector addition operator.
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    friend Vector operator+ ( const Vector& a, const Vector& b )
    { 
      LinearAlgebra::Vector result(a);
      return( result += b );
    }
    
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief %Vector subtraction operator.
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    friend Vector operator- ( const Vector& a, const Vector& b )
    {
      LinearAlgebra::Vector result(a);
      return( result -= b );
    }
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief %Vector negation operator.
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    friend Vector operator- ( const Vector& a )
    {
      LinearAlgebra::Vector result(a);
      return( result *= -1.0 ); 
    }
    
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Vector-Vector product operator.
    ///
    /// Yields a matrix 
    /// \f[ M_{i,j} = a_i * b_j \f]
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    friend Matrix operator* ( const Vector& a, const Vector& b );
  //@}
    
  //@{
    /// \name %Vector functions
    
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Dot product
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    friend double dot( const Vector& a, const Vector& b ) 
    { return( std::inner_product(a.mData, a.mData+a.mSize, b.mData, 0.0) ); }
    
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief %Vector magnitude
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    friend double mag( const Vector& a ) 
    { return( ::sqrt( dot(a,a) ) ); }
    
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Vector magnintude squared
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    friend double mag2( const Vector& a ) 
    { return( dot(a,a) ); }
    
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Absolute maximum of the vector elements.
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    friend double absmax( const Vector& a )
    { 
      double Max = 0.0;
      for ( int i = 0; i < a.mSize; ++i )
      {
        const double Value =  fabs(a.mData[i]);
        Max = std::max( Max, Value );
      }
      
      return( Max ); 
    }
    
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Absolute minimum of the vector elements.
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    friend double absmin( const Vector& a )
    {
      double Min = std::numeric_limits<double>::max();
      for ( int i = 0; i < a.mSize; ++i )
      {
        const double Value =  fabs(a.mData[i]);
        Min = std::min( Min, Value );
      }
      
      return( Min );
    }
    
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Maximum of the vector elements.
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    friend double max( const Vector& a )
    { return( *std::max_element( a.mData, a.mData+a.mSize ) ); }
      
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Minimum of the vector elements.
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
    friend double min( const Vector& a )
    { return( *std::min_element( a.mData, a.mData+a.mSize ) ); }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
    /// \brief Computes the sum of the vector elements.
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
    friend double sum( const Vector& a )
    { return( std::accumulate( a.mData, a.mData+a.mSize, 0.0 ) ); }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
    /// \brief Computes the sum of magnitudes of the vector elements.
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
    friend double asum( const Vector& a )
    {
      double sum = 0.0;

      for ( int i = 0; i < a.mSize; ++i )
        sum += fabs(a.mData[i]);

      return( sum );
    }    
    
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Computes the L2 norm of the vector
    /// 
    /// \f[ \frac{1}{N} \sqrt{ \sum_i a_i } \f]
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
    friend double L2norm( const Vector& a )
    { return( mag(a)/a.mSize ); }

    // friend Vector inv( const Vector& a );
    // friend Vector operator/( const Vector& a, const Vector& b );
    // friend Vector sqrt( const Vector& a );
    // friend Vector invsqrt( const Vector& a );
    // friend Vector cbrt( const Vector& a );
    // friend Vector invcbrt( const Vector& a );
    // friend Vector pow( const Vector& a, const Vector& b );
    // friend Vector pow( const Vector& a, const double b );
    // //friend Vector hypot( const Vector& a, const Vector& b );
    // friend Vector exp( const Vector& a );
    // friend Vector ln( const Vector& a );
    // friend Vector log10( const Vector& a );
    // friend Vector cos( const Vector& a );
    // friend Vector sin( const Vector& a );
    // friend void sincos( const Vector& a, Vector& c, Vector& s );
    // friend Vector tan( const Vector& a );
    // friend Vector acos( const Vector& a );
    // friend Vector asin( const Vector& a );
    // friend Vector atan( const Vector& a );
    // friend Vector atan2( const Vector& a, const Vector& b );
    // friend Vector cosh( const Vector& a );
    // friend Vector sinh( const Vector& a );
    // friend Vector tanh( const Vector& a );
    // friend Vector acosh( const Vector& a );
    // friend Vector asinh( const Vector& a );
    // friend Vector atanh( const Vector& a );
    // friend Vector erf( const Vector& a );
    // friend Vector erfc( const Vector& a );
    //friend Vector erfinv( const Vector& a );
    //friend Vector floor( const Vector& a );
    //friend Vector ceil( const Vector& a );
    //friend Vector trunc( const Vector& a );
    //friend Vector round( const Vector& a );
    //friend Vector nearbyint( const Vector& a );
    //friend Vector rint( const Vector& a );
    //friend void modf( const Vector& a, Vector& it, Vector& frac );    

    // friend Vector abs( const Vector& a );       
    
  private:
    void AllocateMemory( void ) 
    { mData = new double[mSize]; }
    
	  void ReleaseMemory( void ) 
    { 
      if ( mData != NULL ) 
        delete[] mData; 
      mData = NULL;
    }
    
    void StraightCopy( const Vector& v ) 
    { std::copy( v.mData, v.mData+v.mSize, mData ); } 
    
    void AllocateCopy( const Vector& v ) 
    { 
      ReleaseMemory(); 
      AllocateMemory(); 
      StraightCopy(v); 
    }
    
    size_t mSize;
    double* mData;        
  };	// Class: Vector
  
  void Plot( const Vector& a, const std::string& Title = "Vector" );
    
}	// Namespace: LinearAlgebra

#endif

