#ifndef _COUNTEDARRAY_HPP_07192004_
#define _COUNTEDARRAY_HPP_07192004_

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
/// \file
/// \brief Reference counted array pointer.
/// \ingroup mem
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "Assert.hpp"
#include "SafeDelete.hpp"

#include <cstring>

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Templated reference counted c-style array.
///
/// Automatically releases the array when the reference count goes to zero. Do not create using a prexisting pointer or side 
/// effects can result.
/// \ingroup mem
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template <class TYPE>
class CountedArray
{
public:
//@{
  /// \name Constructors and Destructor
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Array pointer constructor.
  /// \param a [in] Pointer to array of TYPE.
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  explicit CountedArray( TYPE* a = NULL ) : pCounter(NULL) 
  { 
    if ( a )
      pCounter = new Counter(a); 
  }
  
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Counted array copy constructor.
  /// \param a [in] Counted array to copy.
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  CountedArray( const CountedArray& a ) throw() 
  { Acquire( a.pCounter ); }
  
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Counted array destructor.
  ///
  /// Reduces the reference count by one and relases the array if count is zero.
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  ~CountedArray( void ) 
  { Release(); }
//@}

//@{ 
  /// \name Assignment operator
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Counted array assignment operator.
  /// 
  /// Does not copy the data, it only increments the counter.  Both will not point to the same data in memory.
  /// \param a [in] Counted array to assign.  
  /// \return Reference to *this.
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  CountedArray& operator= ( const CountedArray& a )
  {	
    if ( this != (&a) )
    {
      Release();
      Acquire( a.pCounter );
    }     
    return( *this );
  }
//@}

//@{
  /// \name Subscript operators  
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Return by reference subscript operator.
  ///
  /// No range checking is performed.
  /// \param n [in] Index into the array.
  /// \return Reference to the n-th element in the array.
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  TYPE& operator[] ( const size_t n ) 
  { 
    Assert( pCounter != NULL, "Uninitialized pointer", __FILE__, __FUNCTION__, __LINE__ );
    Assert( pCounter->ptr != NULL, "Uninitialized pointer", __FILE__, __FUNCTION__, __LINE__ );
    return( (pCounter->ptr)[n] ); 
  }

  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Constant subscript operator
  /// 
  /// No range checking is performed.
  /// \param n [in] Index into the array.
  /// \return The n-th element of the array.
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  TYPE operator[] ( const size_t n ) const
  {
    Assert( pCounter != NULL, "Uninitialized pointer", __FILE__, __FUNCTION__, __LINE__ );
    Assert( pCounter->ptr != NULL, "Uninitialized pointer", __FILE__, __FUNCTION__, __LINE__ );
    return( (pCounter->ptr)[n] ); 
  }
//@}
    
//@{
  /// \name Pointer status functions
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Checks if pointer is unique.
  ///
  /// Being unique means that there are no other reference to this pointer.
  /// \param p [in] Counted array to check for uniqueness.
  /// \return True is the reference count for p is 1 or the pointer is NULL, else false.
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  friend bool IsUnique( const CountedArray<TYPE> p ) 
  { return( p.pCounter ? (p.pCounter->count == 1) : true ); }
  
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Checks if pointer is NULL.
  /// \param p [in] Counted array to check.
  /// \return True is the pointer is NULL, else false.
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  friend bool IsNull( const CountedArray<TYPE> p )
  { return( p.Get() == NULL ); }

  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Checks if pointer is valid (not NULL).
  /// \param ptr [in] Counted array to check.
  /// \return True is the pointer is not NULL, else false.
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  friend bool IsValid( const CountedArray<TYPE> ptr )
  { return( !IsNull(ptr) ); }
//@}

//@{
  /// \name Comparison operators
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Equality operator
  ///
  /// Checks if the two counted arrays point to the same data.
  /// \param p1 [in] First counted array to compare.
  /// \param p2 [in] Second counted array to compare.
  /// \return True if both arrays point to the same data, else false.
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  friend bool operator== ( const CountedArray<TYPE>& p1, const CountedArray<TYPE>& p2 )
  { return( p1.Get() == p2.Get() ); }
//@}

//@{
  /// \name Memory functions  
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief memset function for counted arrays.
  ///
  /// Sets the raw memory in the array to a given integer value.
  /// \param buffer [out] Counted array to memset.
  /// \param c [in] Integer value to set.
  /// \param num [in] Number of bytes to set.
  /// \return Reference to buffer.
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  friend CountedArray<TYPE>& memset( CountedArray<TYPE>& buffer, int c, unsigned int num )
  {
    memset( buffer.Get(), c, num );
    return( buffer ); 
  }
  
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief memcpy function for counted arrays.
  ///
  /// If the source and destination overlap, then data might not be preserved.
  /// \param dest [out] Destination for the data.
  /// \param src [in] Source for the data.
  /// \param num [in] Number of bytes to copy.
  /// \return Reference to dest.
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  friend CountedArray<TYPE>& memcpy( CountedArray<TYPE>& dest, const CountedArray<TYPE>& src, unsigned int num )
  {
    memcpy( dest.Get(), src.Get(), num );
    return( dest ); 
  }
//@}

private:
  TYPE* Get( void ) const
  { return (pCounter ? pCounter->ptr : NULL); }
  
  TYPE* Get( void )
  { return (pCounter ? pCounter->ptr : NULL); }

  //! Reference counter structure.
  struct Counter
  {
    Counter( TYPE* p = NULL, unsigned int c = 1 ) : ptr(p), count(c) { ; }
    TYPE* ptr;
    unsigned int count;
  }* pCounter;
    
  void Acquire( Counter* c ) throw()
  {
    pCounter = c;
    if (c)	
      ++(c->count);
  }
    
  void Release( void )
  {
    if (pCounter)
      if (  --(pCounter->count) == 0  )
      {
        SafeDeleteArray(pCounter->ptr);
        SafeDelete(pCounter);
      } 
  }
};

#endif
