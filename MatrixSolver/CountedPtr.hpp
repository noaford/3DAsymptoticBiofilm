#ifndef _COUNTEDPTR_HPP_10222003_
#define _COUNTEDPTR_HPP_10222003_

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// \file
/// \brief Reference counted pointer.
/// \ingroup mem
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Utility library includes
#include "Assert.hpp"
#include "SafeDelete.hpp"

#ifdef _USE_INTEL_TBB_
  // Intel Threading Building Blocks includes
  #include "tbb/atomic.h"
#endif

// STL includes
#include <ostream>

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Templated reference counted pointer.
///
/// Automatically releases the memory when there are no more references to the memory.  Do not create using an existing pointer as
/// side effects may result.
/// \ingroup mem
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template <class TYPE> 
class CountedPtr
{    
public:
//@{
  /// \name Constructors and Destructor
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief TYPE pointer constructor.
  /// \param p [in] Pointer to TYPE
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  explicit CountedPtr( TYPE* p = NULL ) : Counter(NULL) 
  { 
    if ( p ) 
      Counter = new counter(p); 
  }
  
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Shallow copy contructor.
  ///
  /// Does not copy the memory, it only increments the reference count.  Both counted pointers reference the same memory location.
  /// \param r [in] Reference to a counted pointer of type TYPE.
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  CountedPtr( const CountedPtr& r) throw() 
  { 
    Acquire(r.Counter); 
  }
  
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Destructor.
  ///
  /// Reduces the reference count by one and releases the memory pointed to if count is zero.
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  ~CountedPtr( void ) 
  { 
    Release(); 
  }
//@}
  
//@{
  /// \name Assignment operator
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Counted pointer assignment operator.
  ///
  /// Does not copy the data, it only increments the reference count and both pointers point to the same memory location.
  /// \param r [in] Constant reference to counted pointer to assign. 
  /// \return Reference to *this after assignment.
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
  CountedPtr& operator= ( const CountedPtr& r )
  {
    
    if (this != &r) 
    {
      Release();
      Acquire(r.Counter);
    }
    return (*this);
  }
//@}

//@{
  /// \name Reference operators
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Pointer dereference operator.
  /// \return Reference to the data pointed to by the pointer.
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  TYPE& operator*( void ) const throw() 
  {
    Assert( Counter != NULL, "Uninitialized pointer", __FILE__, __FUNCTION__, __LINE__ );
    Assert( Counter->ptr != NULL, "Uninitialized pointer", __FILE__, __FUNCTION__, __LINE__ );
    return (*Counter->ptr); 
  }
  
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Member reference operator.
  /// \return Pointer to the memory referenced by the counted pointer.
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  TYPE* operator->( void ) const throw() 
  {
    Assert( Counter != NULL, "Uninitialized pointer", __FILE__, __FUNCTION__, __LINE__ );
    Assert( Counter->ptr != NULL, "Uninitialized pointer", __FILE__, __FUNCTION__, __LINE__ );
    return (Counter->ptr); 
  }
  
//@{
  /// \name Output stream operator
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Output Stream Insert Operator
  ///
  /// Inserts the address of the counted pointer to the stream.
  /// \param os [in,out] Output stream into insert into.
  /// \param p [in] Counted Pointer to insert into the stream.
  /// \return Reference to output stream after insertion.
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  friend std::ostream& operator<< ( std::ostream& os, const CountedPtr<TYPE>& p )
  { return( os << p.Get() ); }
//@}

//@{
  /// \name Pointer status functions  
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Checks if the pointer is NULL.
  /// \return True if the pointer is NULL, false otherwise.
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  friend bool IsNull( const CountedPtr<TYPE>& p )
  { return( p.Get() == NULL ); }
  
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Checks if the pointer is not NULL.
  /// \return True if the pointer is valid, false otherwise.  Same as !IsNull(p).
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  friend bool IsValid( const CountedPtr<TYPE>& ptr )
  { return( !IsNull(ptr) ); }
  
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Checks if the Pointer is only referenced once.
  /// \return True if reference count is one or a NULL pointer was used for contruction, false otherwise.
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  friend bool IsUnique( CountedPtr<TYPE>& p )
  { return( p.Counter ? (p.Counter->count == 1) : true ); }
//@}

//@{
  /// \name Comparison operators
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Equality operator.
  /// \param p1 [in] First counted pointer to compare.
  /// \param p2 [in] Second counted pointer to compare.
  /// \return True is both pointers point to the same memory location, else false.
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  friend bool operator== ( const CountedPtr<TYPE>& p1, const CountedPtr<TYPE>& p2 )
  { return( p1.Get() == p2.Get() ); }
//@}

//@{
  /// \name Memory functions   
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief memset function for counted pointers.
  /// \param buffer [in] Counted pointer to set.
  /// \param c [in] Value to set the memory to.
  /// \param num [in] Size of the data.
  /// \return Reference to buffer after the memset.
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  friend CountedPtr<TYPE>& memset( CountedPtr<TYPE>& buffer, int c, unsigned int num )
  {
    memset( buffer.Get(), c, num );
    return( buffer ); 
  }
 
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief memcpy function for counted pointers.
  /// \param dest [in] Memory destination.
  /// \param src [in] Memory source.
  /// \param num [in] Size of the data to copy.
  /// \return Reference to dest after the memcpy.
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  friend CountedPtr<TYPE>& memcpy( CountedPtr<TYPE>& dest, const CountedPtr<TYPE>& src, unsigned int num )
  {
    memcpy( dest.Get(), src.Get(), num );
    return( dest ); 
  }

  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Performs a deep copy.
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  friend CountedPtr<TYPE> deepCopy( const CountedPtr<TYPE>& src )
  { return( CountedPtr<TYPE>( new TYPE( *(src) ) ) ); }
//@}
    
private:
  TYPE* Get( void ) const
  { return (Counter ? Counter->ptr : NULL); }
  
  TYPE* Get( void )
  { return (Counter ? Counter->ptr : NULL); }

  //! Reference counting structure.
#ifdef _USE_INTEL_TBB_
  struct counter 
  {
    counter(TYPE* p = 0, unsigned int c = 1) : ptr(p) 
    { count = c; }
    
    TYPE*          ptr;
    tbb::atomic<unsigned int> count;
  }* Counter;
#else
  struct counter 
  {
    counter(TYPE* p = 0, unsigned int c = 1) : ptr(p), count(c) 
    { ; }
    
    TYPE*          ptr;
    unsigned int   count;
  }* Counter;
#endif
  
  
    
  void Acquire(counter* c) throw()
  {     
    Counter = c;
    if (c) 	
    {
      ++(c->count);
    }
  }
    
  void Release( void )
  {     
    if (Counter) 
    {      
      if (  --(Counter->count) == 0  ) 
      {      
        SafeDelete(Counter->ptr);
        SafeDelete(Counter);
      }                      
    }
  }
  
};	// Class: CountedPtr

#endif 
